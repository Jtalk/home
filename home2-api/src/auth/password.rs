use base64ct;
use base64ct::Encoding;
use derive_more::From;
use pbkdf2::password_hash::rand_core::RngCore;
use pbkdf2::password_hash::{
    rand_core::OsRng, Error as PHashError, ParamsString, PasswordHash, PasswordHashString,
    PasswordHasher, PasswordVerifier, Salt, SaltString,
};
use pbkdf2::{Algorithm, Params, Pbkdf2};

use crate::auth::model::PasswordType;

const SALT_LENGTH: usize = 32;
const PBKDF2_HASH_SEPARATOR: &str = "$"; // We could use the standardised PHC string, but I want to move to OAuth
const PBKDF2_ALGORITHM: Algorithm = Algorithm::Pbkdf2Sha512;
const PBKDF2_ROUNDS: u32 = 65536;
const PBKDF2_OUTPUT_LENGTH: usize = 64;

#[derive(Debug, From)]
pub enum Error {
    Underlying(PHashError),
    Decode(base64ct::Error),
    InvalidFormat(&'static str),
}
pub type Result<T> = std::result::Result<T, Error>;

pub trait PasswordSupport {
    fn hash(&self, password: &str) -> String;
    fn check(&self, password: &str, hash: &str) -> Result<bool>;
}

pub fn new(password_type: PasswordType) -> impl PasswordSupport {
    match password_type {
        PasswordType::PBKDF2WithHmacSHA512 => PBKDF2WithHmacSHA512Support {},
    }
}

struct PBKDF2WithHmacSHA512Support {}

impl PasswordSupport for PBKDF2WithHmacSHA512Support {
    fn hash(&self, password: &str) -> String {
        let salt = gen_salt();
        let result = Pbkdf2
            .hash_password_customized(
                password.as_bytes(),
                Some(PBKDF2_ALGORITHM.ident()),
                None,
                pbkdf2_params(),
                &salt,
            )
            .unwrap(); // password length should not affect the hash, everything else is 500 internal server error
        let hash = result.hash.expect("Hash must be generated by the library");
        let salt = result.salt.expect("Salt must be relayed by the library");

        let hash_enc = base64ct::Base64::encode_string(hash.as_bytes());
        let mut salt_buff = [0u8; Salt::MAX_LENGTH];
        let salt_raw = salt.b64_decode(&mut salt_buff).unwrap();
        let salt_enc = base64ct::Base64::encode_string(salt_raw);

        format!("{}{}{}", hash_enc, PBKDF2_HASH_SEPARATOR, salt_enc)
    }

    fn check(&self, password: &str, hash: &str) -> Result<bool> {
        let parsed = parse_hash(hash)?;
        match Pbkdf2.verify_password(password.as_bytes(), &parsed.password_hash()) {
            Ok(_) => Ok(true),
            Err(PHashError::Password) => Ok(false),
            Err(e) => Err(Error::Underlying(e)),
        }
    }
}

fn gen_salt() -> SaltString {
    let mut bytes = [0u8; SALT_LENGTH];
    OsRng.fill_bytes(&mut bytes);
    SaltString::b64_encode(&bytes).unwrap()
}

fn pbkdf2_params() -> Params {
    Params {
        rounds: PBKDF2_ROUNDS,
        output_length: PBKDF2_OUTPUT_LENGTH,
    }
}

fn parse_hash(hash: &str) -> Result<PasswordHashString> {
    let mut split = hash.split(PBKDF2_HASH_SEPARATOR);
    let hash_v = split.next().expect("At least one element for String.split");
    let salt_v = split
        .next()
        .ok_or(Error::InvalidFormat("Separator not found"))?;
    if split.next().is_some() {
        return Err(Error::InvalidFormat(
            "Too many separators in the hashed string",
        ));
    }

    let hash_bin = base64ct::Base64::decode_vec(hash_v)?;
    let salt_bin = base64ct::Base64::decode_vec(salt_v)?;
    let salt_str = base64ct::Base64Unpadded::encode_string(&salt_bin);
    let salt = Salt::new(salt_str.as_str()).unwrap();

    let borrowed = PasswordHash {
        algorithm: PBKDF2_ALGORITHM.ident(),
        hash: Some(hash_bin.as_slice().try_into()?),
        salt: Some(salt),
        params: ParamsString::try_from(pbkdf2_params())?,
        version: None,
    };
    Ok(PasswordHashString::from(borrowed))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn passwod_hash_check_pbkdf2_hmac_sha512() {
        let password = "password";
        let instance = new(PasswordType::PBKDF2WithHmacSHA512);
        let hash = instance.hash(password);
        let result = instance.check(password, &hash).unwrap();
        assert!(result);
        assert!(!hash.contains(password));
    }

    #[test]
    fn password_check_backward_compatible_pbkdf2_hmac_sha512() {
        // This is the hash of the localdev user, generated by the old API.
        // This tests ensures the new crypto impl is compatible with the old API's data
        // still present in the database.
        let hash = "UxIDTgbpYJvEDWeZRZqktTjeptr40nfnMoD4deJhw/6kgQ/YZ81PqNQi4iPuTylp+Kvc1/jaGoT9b/cR8sKmEg==$OcEyeV7Cb7/pNQROtHg9bDICJPdw7w3JP3lYiaJuZMM=";
        let password = "password";
        let instance = new(PasswordType::PBKDF2WithHmacSHA512);
        let ok = instance.check(&password, &hash).unwrap();
        assert!(ok)
    }
}
